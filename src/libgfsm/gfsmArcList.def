
/*=============================================================================*\
 * File: gfsmArcList.def
 * Author: Bryan Jurish <moocow@ling.uni-potsdam.de>
 * Description: finite state machine library: arc lists: inline definitions
 *  + formerly defined in gfsmArc.h
 *
 * Copyright (c) 2007 Bryan Jurish
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *=============================================================================*/

/*======================================================================
 * Methods: gfsmArcListOld
 */

//--------------------------------------------------------------
// arclist_new_full()
static inline
gfsmArcListOld *gfsm_arclist_new_full_old(gfsmStateId     src,
					  gfsmStateId     dst,
					  gfsmLabelVal    lo,
					  gfsmLabelVal    hi,
					  gfsmWeight      wt,
					  gfsmArcListOld *nxt)
{
  return g_slist_prepend(nxt, gfsm_arc_new_full(src,dst,lo,hi,wt));
}


//--------------------------------------------------------------
// arclist_clone()
static inline
gfsmArcListOld *gfsm_arclist_clone_old(gfsmArcListOld *src)
{
  gfsmArcListOld *al;
  gfsmArcListOld *dst = g_slist_copy(src);
  for (al=dst; al!=NULL; al=al->next) {
    al->data = gfsm_arc_copy(al->data);
  }
  return dst;
}

//--------------------------------------------------------------
// arclist_free()
static inline
gfsmArcListOld *gfsm_arclist_free_old(gfsmArcListOld *al)
{
  while (al != NULL) {
    gfsm_arc_free(al->data);
    al = g_slist_delete_link(al,al);
  }
  return NULL;
}

//--------------------------------------------------------------
// arclist_length()
static inline
guint gfsm_arclist_length_old(gfsmArcListOld *al)
{
  return g_slist_length(al);
}

//--------------------------------------------------------------
// arclist_insert_link()
static inline
gfsmArcListOld *gfsm_arclist_insert_link_old(gfsmArcListOld *al, gfsmArcListOld *link, gfsmArcSortData *sdata)
{
  if (!sdata || sdata->mode == gfsmASMNone) {
    return g_slist_concat(link,al);
  } else {
    gfsmArcListOld *al_first=al;
    gfsmArcListOld *al_prev=NULL;
    gfsmArc         *a = (gfsmArc*)(link->data);

    for (; al != NULL; al_prev=al, al=al->next) {
      if (gfsm_arc_compare(a, (gfsmArc*)(al->data), sdata) <= 0) break;
    }

    if (al_prev == NULL) return g_slist_concat(link,al);
    al_prev->next = g_slist_concat(link, al);
    return al_first;
  }
}

//--------------------------------------------------------------
// arclist_sort_full()
static inline
gfsmArcListOld *gfsm_arclist_sort_full_old(gfsmArcListOld *al, GCompareDataFunc cmpfunc, gpointer data)
{
  return g_slist_sort_with_data(al, cmpfunc, data);
}

//--------------------------------------------------------------
// arclist_sort()
static inline
gfsmArcListOld *gfsm_arclist_sort_old(gfsmArcListOld *al, gfsmArcSortData *sdata)
{
  return gfsm_arclist_sort_full_old(al, (GCompareDataFunc)gfsm_arc_compare, sdata);
}
