------------------------------------------------------------------------
AT&T fsm API:
 + struct FSMArcsClass: next,close,reset,seekpos,seekeps,seeknoneps,seeklabel
 + struct FSMARcsIter : { FSMArc* arcsmin, *arcs, *arcsmax; void *data; FSMArcsClass *clas; }
 + struct FSMClass    : arcsopen,setarcs,addarcs,arcs(fsm,qid,FSMArc **arcs)

------------------------------------------------------------------------
gfsmArcList desiderata
 + arclist_add(al,ARCSPEC)   : generic arc-addition
 + arclist_sort(al,cmp,data) : sorting
 + for arciter interface:
   - arciter_open()        --> arciter_open_list(&ai,al)
   - arciter_insert()      --> arclist_splice(al,aipos,ARCSPEC)
   - arciter_copy()        --> arclist_copy_shallow(dst,src)
   - arciter_open_sorted() --> arclist_clone(), arclist_sort()
   - arciter_remove()      --> arclist_remove(al,aipos)
 + for automaton arciter interface(?)
   - (?) automaton_open_arcs (fsm,qid,&al)
   - (?) automaton_set_arcs  (fsm,qid,&al)
   - (?) automaton_close_arcs(fsm,qid,&al)
   --> THEN:
     * arciter_open(&ai,fsm,qid) { ai->owner={fsm,qid}; automaton_open_arcs(fsm,qid,&(ai->l)); }
     * arciter_open_sorted(...)  {
         if (fsm->sortmode==SORTMODE) { return arciter_open(&ai,fsm,qid); }
	 ArcList al0;
	 automaton_open_arcs(fsm,qid,&al0);
	 arclist_copy_deep(&(ai->l), &al0);
	 arclist_sort(&(ai->l));
	 return ai;
       }
     * arciter_close(&ai)            { automaton_close_arcs(ai->owner.fsm, ai->owner.qid, &(ai->l)); }
     * arciter_copy_shallow(dst,src) { (*dst)=(*src); }
     * arciter_copy_deep(dst,src)    { arclist_copy_deep(&(dst->l),&(src->l)); }
     * arciter_remove(&ai)           { ai->l = arclist_remove(&(ai->l), ai->pos); } ?!?!?!

gfsmArcIter desiderata
 + arciter_close(&ai)        : not yet, must be added!
 + arciter_open(&ai,fsm,qid) : many uses
 + arciter_ok(&ai)           : many uses
 + arciter_next(&ai)         : many uses
 + arciter_seek_X(&ai,LABS)  : optional, recommended
 + arciter_insert(&ai,ARCSPEC)
   - splice arc {q1,q2,lo,hi,w} in at ai's current position
   - e.g. automaton_complete()
 + arciter_copy_shallow(&ai_dst,&ai_src)
   - save current arc-iterator position without duplicating list
   - e.g. compose_visit_state(), intersect_visit_state()
 + arciter_open_sorted(&ai,fsm,qid,sort_mode)
   - open (possibly temporary) arciter on fully sorted arc-list
   - e.g. compose_visit_state(), intersect_visit_state()
 + arciter_remove() : remove current arc


------------------------------------------------------------------------
gfsmArcList* uses:
  + gfsmAlgebra.c
    - complete()
      * uses literal GSList fields to add (missing) arcs while iterating
        - can maybe use arciter if we ensure a mutable automaton...
	- --> arciter_insert(aip,q1,q2,lo,hi,w) : splice arc {q1,q2,lo,hi,w} in at aip's current position
    - compose_visit(), intersect_visit()
      * literal arclists al1,al2,ai1,ai2,ai1_noneps,ai2_noneps,ai2_continue
        --> arciter over temporary lists: arciter_open_list()...arciter_close()
	--> arciter state-saving: arciter_copy(dst,src), [vs. arciter_copy_deep(dst,src)?]
	    ~ should work out to (*dst)=(*src), but don't believe that will always be the case...
      * construction of & iteration over temporary sorted arc-lists:
        ~ arclist_sort(g_slist_copy(q1->arcs), &sortdata)
        ~ --> sorted_arclist(fsm,qid)? sort(shallow_clone(arcs(fsm,qid))) ? 
      * arc-iteration & range-saving via GSList fields
        ~ --> arciter_copy(dst, src, do_copy_list, do_copy_cur)?
    - connect_bw_visit_state()
      * use of gfsmReverseArcIndex structure: gfsmArc *arc = ((gfsmArc*)g_ptr_array_index(rarcs, ...))->data;
        ~ --> either revise gfsmReverseArcIndex to use generic gfsmArcList, or use GSList literally
    - reverse()
      * arc stealing during reversal; uses ArcList & assumes GSList
        ~ --> very tricky: maybe an implementation-dependent 'move_arc(arc)' method?
	      + could assume {source,target} have been modified & move it
	      + hard to implement for singly-linked lists without maintaining a 'prev' pointer
	  --> alt: load up a ReverseArcIndex with full arc copies, flip 'em around & feed 'em back in
	      with gfsm_automaton_add_arc()
	  --> alt: arciter_steal_arc() + automaton_add_arc()
	  --> alt: arciter_remove() + automaton_add_arc()
    - union()
      * sort arcs for added states: s1->arcs = gfsm_arclist_sort(s1->arcs, &sortdata)
        ~ purpose: maintain sort-mode:
	~ --> we can detect sort-mode mismatches easily, on mismatch, bash output mode to gfsmASMNone!
	~ --> get rid of too-smart-for-its-own-good sorting in union()
      
  + gfsmArc.[ch] : definitions
    - arc
    - prepend
    - insert, insert_link
    - copy
    - free
    - free1
    - length
    - sort

  + gfsmArcIndex.[ch]:
    - gfsmReverseArcIndex target data type
      * arclist_prepend() in automaton_reverse_arc_index() --> generic add()!

  + [easy] gfsmAutomaton.[ch] (old basic impl)
    - automaton_remove_state(): arclist_free(s->arcs) --> impl
    - add_arc(): arclist_new_full() --> impl
    - automaton_add_arc_link() [.h]: --> impl
    - automaton_add_arc_link() [.c]: arclist_insert_link() --> impl
    - automaton_arcsort(): arclist_sort() --> impl? or keep arclist_sort()?  or both?

  + [easy] gfsmAutomatonIO.c:
    - load_bin_handle_0_0_8()
      * st->arcs = gfsm_arclist_new_full(...); --> impl
      * st->arcs = g_slist_reverse(st->arcs);  --> impl
    - load_bin_handle_0_0_7()
      * st->arcs = (gfsmArcList*) GUINT_TO_POINTER(s_state.n_arcs); --> impl
      * st->arcs = gfsm_arclist_new_full(...) --> impl
      * st->arcs = g_slist_reverse(st->arcs)  --> impl

  + [easy] gfsmState.[ch]:
    - .h: gfsmState.arcs : struct field --> impl
    - state_new_full(): param 'arcs' --> impl
    - state_copy(): g_slist_concat(arclist_copy(src->arcs), dst->arcs) --> impl
    - state_clear:  arclist_free(s->arcs) --> impl
    - state_free:   arclist_free(s->arcs) --> impl
     
literal GSList* uses:
  + (ok) gfsmLookup.[ch]: lookup stack, viterbi trellis
  + (ok) gfsmMem.h: allocator decl
  + (ok) gfsmPaths.[ch] : string-list
  + (ok) gfsmSet.[ch] : set_to_slist()
  + gfsmAlgebra.c
    - compose_visit(), intersect_visit(): gfsm_arclist_sort(g_slist_copy(),...) ... g_slist_free()
  + gfsmArc.[ch]     : definitions & basic implementation --> impl
  + gfsmArcIter.[ch] : definitions & basic implementation --> impl
  + gfsmAutomatonIO.c : g_slist_reverse() for sorted automaton --> impl
  + gfsmState.[ch] : state_copy(): g_slist_concat(...) --> impl or chuck
