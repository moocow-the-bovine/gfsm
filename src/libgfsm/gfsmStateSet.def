
/*=============================================================================*\
 * File: gfsmStateSet.def
 * Author: Bryan Jurish <moocow@ling.uni-potsdam.de>
 * Description: finite state machine library: state sets: inlined definitions
 *
 * Copyright (c) 2004-2007 Bryan Jurish.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *=============================================================================*/

/*======================================================================
 * Constants
 */
//-- EXTERN

/*======================================================================
 * Methods: Constructors etc.
 */

//--------------------------------------------------------------
// sized_new()
static inline
gfsmStateSet *gfsm_stateset_sized_new(guint isize) 
{
  return g_array_sized_new(FALSE,TRUE,sizeof(gfsmStateId),isize);
}

//--------------------------------------------------------------
// new()
static inline
gfsmStateSet *gfsm_stateset_new(void)
{
  return gfsm_stateset_sized_new(gfsmStateSetDefaultSize);
}

//--------------------------------------------------------------
// new_singleton()
static inline
gfsmStateSet *gfsm_stateset_new_singleton(gfsmStateId id)
{
  gfsmStateSet *sset = gfsm_stateset_new();
  g_array_insert_val(sset,0,id);
  return sset;
}

//--------------------------------------------------------------
// clear()
static inline
void gfsm_stateset_clear(gfsmStateSet *sset)
{
  g_array_set_size(sset,0);
}

//--------------------------------------------------------------
// clone()
static inline
gfsmStateSet *gfsm_stateset_clone(gfsmStateSet *src)
{
  return g_array_append_vals(gfsm_stateset_sized_new(src->len), src->data, src->len);
}

//--------------------------------------------------------------
// free()
static inline
void gfsm_stateset_free(gfsmStateSet *sset)
{
  g_array_free(sset,TRUE);
}

/*======================================================================
 * Methods: Accessors
 */

//--------------------------------------------------------------
// min()
static inline
gfsmStateId gfsm_stateset_min(gfsmStateSet *sset)
{
  return sset->len > 0 ? (*((gfsmStateId*)sset->data)) : gfsmNoState;
}

//--------------------------------------------------------------
// size()
static inline
guint gfsm_stateset_size(gfsmStateSet *sset)
{
  return sset->len;
}

//--------------------------------------------------------------
// find()
static inline
gfsmStateSetIter gfsm_stateset_find(gfsmStateSet *sset, gfsmStateId id)
{
  gfsmStateSetIter sseti;
  gfsmStateId      iid;
  for (sseti = gfsm_stateset_iter_begin(sset);
       (iid=gfsm_stateset_iter_id(sseti)) != gfsmNoState;
       sseti = gfsm_stateset_iter_next(sset,sseti))
    {
      if (id == iid) return sseti;
      else if (id < iid) return NULL;
    }
  return NULL;
}

//--------------------------------------------------------------
// contains()
static inline
gboolean gfsm_stateset_contains(gfsmStateSet *sset, gfsmStateId id)
{
  gfsmStateSetIter sseti = gfsm_stateset_find(sset,id);
  return sseti != NULL && *sseti != gfsmNoState;
}

//--------------------------------------------------------------
// insert()
static inline
gboolean gfsm_stateset_insert(gfsmStateSet *sset, gfsmStateId id)
{
  guint i;
  for (i = 0; i < sset->len && id > g_array_index(sset,gfsmStateId,i); i++) ;

  if (i == sset->len) {
    g_array_append_val(sset,id);
  }
  else if (id == g_array_index(sset,gfsmStateId,i)) {
    return TRUE;
  }
  else {
    g_array_insert_val(sset,i,id);
  }
  return FALSE;
}

//--------------------------------------------------------------
// union()
static inline
gfsmStateSet *gfsm_stateset_union(gfsmStateSet *sset1, gfsmStateSet *sset2)
{
  guint i1=0, i2;
  for (i2=0; i2 < sset2->len; i2++) {
    gfsmStateId id = g_array_index(sset2,gfsmStateId,i2);
    for (; i1 < sset1->len && id > g_array_index(sset1,gfsmStateId,i1); i1++) ;

    if (i1 == sset1->len) g_array_append_val(sset1,id);
    else if (id == g_array_index(sset1,gfsmStateId,i1)) continue;
    else g_array_insert_val(sset1,i1,id);
  }
  return sset1;
}


//--------------------------------------------------------------
// remove()
static inline
gboolean gfsm_stateset_remove(gfsmStateSet *sset, gfsmStateId id) {
  guint i;
  for (i = 0; i < sset->len && id > g_array_index(sset,gfsmStateId,i); i++) ;
  if (i != sset->len && id == g_array_index(sset,gfsmStateId,i)) {
    g_array_remove_index(sset,i);
    return TRUE;
  }
  return FALSE;
}

//--------------------------------------------------------------
// equal()
static inline
gboolean gfsm_stateset_equal(gfsmStateSet *sset1, gfsmStateSet *sset2)
{
  guint i;
  if (sset1->len != sset2->len) return FALSE;
  for (i=0; i < sset1->len; i++) {
    if (g_array_index(sset1,gfsmStateId,i) != g_array_index(sset2,gfsmStateId,i)) return FALSE;
  }
  return TRUE;
}


/*======================================================================
 * Methods: Utilities
 */

//--------------------------------------------------------------
// hash()
//-- EXTERN


//--------------------------------------------------------------
// foreach()
static inline
void gfsm_stateset_foreach(gfsmStateSet *sset, gfsmStateSetForeachFunc func, gpointer data)
{
  guint i;
  for (i = 0; i < sset->len; i++) {
    if ((*func)(g_array_index(sset,gfsmStateId,i), data)) break;
  }
}

/*======================================================================
 * Methods: Automaton access
 */

//--------------------------------------------------------------
// populate()
//--EXTERN

//--------------------------------------------------------------
// has_final_state()
static inline
gboolean gfsm_stateset_has_final_state(gfsmStateSet *sset, gfsmAutomaton *fsm)
{
  guint i;
  for (i = 0; i < sset->len; i++) {
    if (gfsm_automaton_is_final_state(fsm, g_array_index(sset,gfsmStateId,i))) return TRUE;
  }
  return FALSE;
}

//--------------------------------------------------------------
// lookup_final_weight()
static inline
gboolean gfsm_stateset_lookup_final_weight(gfsmStateSet *sset, gfsmAutomaton *fsm, gfsmWeight *wp)
{
  guint i;
  gboolean rc=FALSE;
  *wp = fsm->sr->one;
  gfsmWeight w;
  for (i = 0; i < sset->len; i++) {
    gfsmStateId id = g_array_index(sset,gfsmStateId,i);
    if (gfsm_automaton_lookup_final(fsm,id,&w)) {
      *wp = gfsm_sr_plus(fsm->sr, *wp, w);
      rc  = TRUE;
    }
  }
  return rc;
}
